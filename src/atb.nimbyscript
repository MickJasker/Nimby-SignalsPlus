script meta {
  lang: nimbyscript.v1,
  api: nimbyrails.v1,
}

enum AtbSignalState {
  Idle,
  Pass,
  Stop,
}

pub struct AtbSignal extend Signal {
  signals_ahead: &Vec<ID<Signal>>,
}

struct AtbSignalTask {
  state: AtbSignalState,
  station_stop_ahead: bool,
}

pub fn AtbSignal::event_signal_lookahead(
  self: &AtbSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  train_distance: f64,
  check: SignalCheck,
  sc: &mut SimpleSimController,
  result: &mut SignalLookaheadResult
) {
  // show idle if train is farther than 1km, to avoid unnecessary processing
  if train_distance > 1000.0 {
    sc.queue_attach(signal, AtbSignalTask::new(AtbSignalState::Idle, false));
    return;
  }

  let speed = motion.presence.get().speed;
  let max_braking = motion.dynamics.max_regular_braking;
  let stopping_distance = speed * speed / (2.0 * max_braking);
  let within_braking = train_distance + 100.0 <= stopping_distance;

  // Set speed limits for stop signals
  if check == SignalCheck::Stop {
    if train_distance <= 25.0 {
      result.max_speed = 10.0;
    } else if train_distance <= 100.0 {
      result.max_speed = 40.0;
    }
  }

  // Determine signal state
  let state mut= AtbSignalState::Idle;
  if within_braking {
    if check == SignalCheck::Stop {
      state = AtbSignalState::Stop;
    } else {
      state = AtbSignalState::Pass;
    }
  }

  // Check for scheduled station stop within braking distance
  let station_stop mut= false;
  if let stop &= motion.schedule_stop.get() {
    station_stop = train_distance <= stopping_distance;
  }

  sc.queue_attach(signal, AtbSignalTask::new(state, station_stop));
}

pub fn AtbSignal::event_signal_pass_by(
  self: &AtbSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  sc: &mut SimController
) {
  sc.queue_attach(signal, AtbSignalTask::new(AtbSignalState::Idle, false));
}

pub fn AtbSignal::event_signal_texture_state(
  self: &AtbSignal,
  db: &DB,
  signal: &Signal,
  clock_us: i64
): i64 {
  let task = db.view<AtbSignalTask>(signal.id) else { return 0; }

  if task.state == AtbSignalState::Stop {
    return 2;
  }

  if task.state == AtbSignalState::Pass {
    // Caution if station stop ahead
    if task.station_stop_ahead {
      return 3;
    }
    // Caution if any signal ahead shows stop
    for signal_id in self.signals_ahead.iter() {
      let ahead_task = db.view<AtbSignalTask>(signal_id);
      if let ahead &= ahead_task {
        if ahead.state == AtbSignalState::Stop {
          return 3;
        }
      }
    }
    return 1;
  }

  return 0;
}
