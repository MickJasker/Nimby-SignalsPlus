script meta {
  lang: nimbyscript.v1,
  api: nimbyrails.v1,
}

enum SignalPhase {
  Idle,
  Pass,
  Stop,
  Caution,
}

pub struct SignalPlusSignal extend Signal {
  meta { label: "Signals Plus Signal", description: "A signal that shows different aspects based on upcoming signals and train approach. Can show idle, pass, stop, and caution aspects. You can map your own custom signal by changing texture IDs." },

  signals_ahead: &Vec<ID<Signal>> meta { label: "Signals Ahead" },

  off_texture_id: i64 meta { label: "Off Texture ID", default: 0 },
  
  idle_texture_id: i64 meta { label: "Idle Texture ID", default: 0, },
  blink_on_idle: bool meta { label: "Blink on Idle", default: false, description: "If enabled, the signal will blink when in idle state using the 'off' texture." },

  pass_texture_id: i64 meta { label: "Pass Texture ID", default: 1 },
  blink_on_pass: bool meta { label: "Blink on Pass", default: false, description: "If enabled, the signal will blink when in pass state using the 'off' texture." },

  stop_texture_id: i64 meta { label: "Stop Texture ID", default: 2 },
  blink_on_stop: bool meta { label: "Blink on Stop", default: false, description: "If enabled, the signal will blink when in stop state using the 'off' texture." },

  caution_texture_id: i64 meta { label: "Caution Texture ID", default: 3 },
  blink_on_caution: bool meta { label: "Blink on Caution", default: false, description: "If enabled, the signal will blink when in caution state using the 'off' texture." },
}

pub struct SignalPlusStation extend Station {
  approach_signals: &Vec<ID<Signal>> meta { label: "Approach Signals", description: "List of signals that are considered approach signals for this station. When a train is approaching the station and sees one of these signals and is stopping at that station, the signal will show a caution aspect."},
}

struct SignalState {
  state: SignalPhase,
  pass_by_at: i64,
  is_approaching_station: bool,
}

pub fn SignalPlusSignal::event_signal_lookahead(
  self: &SignalPlusSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  train_distance: f64,
  check: SignalCheck,
  sc: &mut SimpleSimController,
  result: &mut SignalLookaheadResult
) {
  let current_speed = motion.presence.get().speed;
  let max_brake = as_f64(motion.dynamics.max_regular_braking);
  let brake_distance = (current_speed * current_speed) / (2.0 * max_brake);

  if (brake_distance + 50.0) < train_distance {
    if let old_state &= ctx.db.view<SignalState>(signal) {
      sc.queue_erase(old_state);
    }
    return;
  }

  // show idle if train is farther than 1km, to avoid unnecessary processing
  if train_distance > 1000.0 {
    if let old_state &= ctx.db.view<SignalState>(signal) {
      sc.queue_erase(old_state);
    }
    return;
  }

  let state mut= SignalPhase::Idle;

  if check == SignalCheck::Pass {
    state = SignalPhase::Pass;
  }

  let is_approach_signal mut= false;
  if let run_dispatch &= motion.run_dispatch.get() {
    let run &= run_dispatch.run;
    if let line &= ctx.db.view(run.line_id) {
      if let current_stop &= run_dispatch.current_stop(line) {
        if let station &= ctx.db.view(current_stop.station_id) {
          if let sp_station &= ctx.db.view<SignalPlusStation>(station) {
            for approach_signal_id in sp_station.approach_signals.iter() {
              if (approach_signal_id.equals(signal.id)) {
                is_approach_signal = true;
                break;
              }
            }

            if is_approach_signal {
              state = SignalPhase::Caution;
            }
          }
        }
      }
    }
  }

  if check == SignalCheck::Stop {
    state = SignalPhase::Stop;
  }

  if let old_state &= ctx.db.view<SignalState>(signal) {
    sc.queue_erase(old_state);
  }

  let task = SignalState::new();
  task.state = state;
  task.is_approaching_station = is_approach_signal;
  sc.queue_attach(signal, task);
}

pub fn SignalPlusSignal::event_signal_pass_by(
  self: &SignalPlusSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  sc: &mut SimController
) {
  if let old_state &= ctx.db.view<SignalState>(signal) {
    let state = old_state.state;
    sc.queue_erase(old_state);
    let task = SignalState::new();
    if (state == SignalPhase::Stop || state == SignalPhase::Idle) {
      if (old_state.is_approaching_station) {
        task.state = SignalPhase::Caution;
      } else {
        task.state = SignalPhase::Pass;
      }
    }
    else {
      task.state = state;
    }
    task.pass_by_at = ctx.extrapolator.clock_us();
    sc.queue_attach(signal, task);
  }
}



pub fn SignalPlusSignal::event_signal_texture_state(
  self: &SignalPlusSignal,
  db: &DB,
  signal: &Signal,
  clock_us: i64,
  core_state: i64
): i64 {

  let cycle = zmod(zdiv(clock_us, 500000), 2);
  if let task &= db.view<SignalState>(signal) {
    if task.pass_by_at > 0 {
      if clock_us - task.pass_by_at >= 2000000 {
        return self.idle_texture_id;
      }
    }

    if task.state == SignalPhase::Stop {
      log("stop", signal.id);

      if (self.blink_on_stop) {
        if cycle == 0 {
          return self.stop_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.stop_texture_id;
      }
    }

    if task.state == SignalPhase::Pass {
      log("pass", signal.id);

      if self.blink_on_pass {
        if cycle == 0 {
          return self.pass_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.pass_texture_id;
      }
    }

    if task.state == SignalPhase::Caution {
      log("caution", signal.id);
      if self.blink_on_caution {
        if cycle == 0 {
          return self.caution_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.caution_texture_id;
      }
    }

    if task.state == SignalPhase::Idle {
      log("idle", signal.id);
      if self.blink_on_idle {
        if cycle == 0 {
          return self.idle_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.idle_texture_id;
      }
    }
  }
  
  for signal_id in self.signals_ahead.iter() {
    if let s &= db.view(signal_id) {
      if let ahead &= db.view<SignalState>(s) {
        if ahead.state == SignalPhase::Stop {
          if self.blink_on_caution {
            if cycle == 0 {
              return self.caution_texture_id;
            } else {
              return self.off_texture_id;
            }
          } else {
            return self.caution_texture_id;
          }
        }
      }
    }
  }

  return self.idle_texture_id;
}
