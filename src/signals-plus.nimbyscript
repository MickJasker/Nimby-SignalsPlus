script meta {
  lang: nimbyscript.v1,
  api: nimbyrails.v1,
}

enum SignalPhase {
  Idle,
  Pass,
  Stop,
  Caution,
  DriveOnSight,
}

pub struct SignalPlusSignal extend Signal {
  signals_ahead: &Vec<ID<Signal>> meta { label: "Signals Ahead", description: "List of signals ahead to check for stop aspects. If any of these signals are showing a stop aspect, this signal will show a caution aspect.", },

  off_texture_id: i64 meta { label: "Off Texture ID", default: 0, description: "Texture shown during blink 'off' phase.", },
  
  idle_texture_id: i64 meta { label: "Idle Texture ID", default: 2, description: "Texture shown when no train is approaching.", },
  blink_on_idle: bool meta { label: "Blink on Idle", default: false, description: "If enabled, the signal will blink when in idle state using the 'off' texture.", },

  pass_texture_id: i64 meta { label: "Pass Texture ID", default: 1, description: "Texture shown when clear to proceed.", },
  blink_on_pass: bool meta { label: "Blink on Pass", default: false, description: "If enabled, the signal will blink when in pass state using the 'off' texture.", },

  stop_texture_id: i64 meta { label: "Stop Texture ID", default: 2, description: "Texture shown when train must stop.", },
  blink_on_stop: bool meta { label: "Blink on Stop", default: true, description: "If enabled, the signal will blink when in stop state using the 'off' texture.", },

  caution_texture_id: i64 meta { label: "Caution Texture ID", default: 3, description: "Texture shown when approaching a stop signal or station.", },
  blink_on_caution: bool meta { label: "Blink on Caution", default: false, description: "If enabled, the signal will blink when in caution state using the 'off' texture.", },

  drive_on_sight_texture_id: i64 meta { label: "Drive On Sight Texture ID", default: 3, description: "Texture shown when approaching a signal when 'check beyond stops is disabled on the signal'", },
  blink_on_drive_on_sight: bool meta { label: "Blink on Drive On Sight", default: true, description: "If enabled, the signal will blink when in drive on sight state using the 'off' texture.", },
}

pub struct SignalPlusStation extend Station {
  approach_signals: &Vec<ID<Signal>> meta { label: "Approach Signals", description: "List of signals that are considered approach signals for this station. When a train is approaching the station and sees one of these signals and is stopping at that station, the signal will show a caution aspect.",},
}

struct SignalState {
  state: SignalPhase,
  pass_by_at: i64,
  is_approaching_station: bool,
}

pub fn SignalPlusSignal::event_signal_lookahead(
  self: &SignalPlusSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  train_distance: f64,
  check: SignalCheck,
  sc: &mut SimpleSimController,
  result: &mut SignalLookaheadResult
) {
  let pos = signal.forward();
  if let track &= ctx.db.view(pos.track_id) {
    let track_speed = track.max_speed();
    let max_brake = as_f64(motion.dynamics.max_regular_braking);
    let brake_distance = max((track_speed * track_speed) / (2.0 * max_brake) * 2.0, 1000.0);
    if (brake_distance) < train_distance {
      return;
    }
  } else {
        return;
  }

  let state mut= SignalPhase::Idle;
  if check == SignalCheck::Pass {
    state = SignalPhase::Pass;
  }

  let is_approach_signal mut= false;
  if let run_dispatch &= motion.run_dispatch.get() {
    let run &= run_dispatch.run;
    if let line &= ctx.db.view(run.line_id) {
      if let current_stop &= run_dispatch.current_stop(line) {
        if let station &= ctx.db.view(current_stop.station_id) {
          if let sp_station &= ctx.db.view<SignalPlusStation>(station) {
            for approach_signal_id in sp_station.approach_signals.iter() {
              if (approach_signal_id.equals(signal.id)) {
                is_approach_signal = true;
                break;
              }
            }

            if is_approach_signal {
              state = SignalPhase::Caution;

              if !signal.check_beyond_stops {
                state = SignalPhase::DriveOnSight;
              }
            }
          }
        }
      }
    }
  }

  if check == SignalCheck::Stop {
    state = SignalPhase::Stop;
  }

  if let old_state &= ctx.db.view<SignalState>(signal) {
    sc.queue_erase(old_state);
  }

  let task = SignalState::new();
  task.state = state;
  task.is_approaching_station = is_approach_signal;
  sc.queue_attach(signal, task);
}

pub fn SignalPlusSignal::event_signal_pass_by(
  self: &SignalPlusSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  sc: &mut SimController
) {
  if let old_state &= ctx.db.view<SignalState>(signal) {
    let state = old_state.state;
    sc.queue_erase(old_state);
    let task = SignalState::new();
    if (state == SignalPhase::Stop || state == SignalPhase::Idle) {
      if (old_state.is_approaching_station) {
        task.state = SignalPhase::Caution;
      } else {
        task.state = SignalPhase::Pass;
      }
    }
    else {
      task.state = state;
    }
    task.pass_by_at = ctx.extrapolator.clock_us();
    sc.queue_attach(signal, task);
  }
}



pub fn SignalPlusSignal::event_signal_texture_state(
  self: &SignalPlusSignal,
  db: &DB,
  signal: &Signal,
  clock_us: i64,
  core_state: i64
): i64 {

  let cycle = zmod(zdiv(clock_us, 500000), 2);
  if let task &= db.view<SignalState>(signal) {
    if task.pass_by_at > 0 {
      if clock_us - task.pass_by_at >= 2000000 {
        return self.idle_texture_id;
      }
    }

    if task.state == SignalPhase::Stop {
      if (self.blink_on_stop) {
        if cycle == 0 {
          return self.stop_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.stop_texture_id;
      }
    }

    for signal_id in self.signals_ahead.iter() {
      if let s &= db.view(signal_id) {
        if let ahead &= db.view<SignalState>(s) {
          if ahead.state == SignalPhase::Stop {
            if self.blink_on_caution {
              if cycle == 0 {
                return self.caution_texture_id;
              } else {
                return self.off_texture_id;
              }
            } else {
              return self.caution_texture_id;
            }
          }
        }
      }
    }

    if task.state == SignalPhase::Pass {
      if self.blink_on_pass {
        if cycle == 0 {
          return self.pass_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.pass_texture_id;
      }
    }

    if task.state == SignalPhase::Caution {
      if self.blink_on_caution {
        if cycle == 0 {
          return self.caution_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.caution_texture_id;
      }
    }

    if task.state == SignalPhase::Idle {
      if self.blink_on_idle {
        if cycle == 0 {
          return self.idle_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.idle_texture_id;
      }
    }

    if task.state == SignalPhase::DriveOnSight {
      if self.blink_on_drive_on_sight {
        if cycle == 0 {
          return self.drive_on_sight_texture_id;
        } else {
          return self.off_texture_id;
        }
      } else {
        return self.drive_on_sight_texture_id;
      }
    }
  }

  if (self.blink_on_idle) {
    if cycle == 0 {
      return self.idle_texture_id;
    } else {
      return self.off_texture_id;
    }
  }

  return self.idle_texture_id;
}
