script meta {
  lang: nimbyscript.v1,
  api: nimbyrails.v1,
}

enum SignalPhase {
  Idle,
  Pass,
  Stop,
  Caution,
}

pub struct SignalPlusSignal extend Signal {
  signals_ahead: &Vec<ID<Signal>>,
}

pub struct SignalPlusStation extend Station {
  approach_signals: &Vec<ID<Signal>>,
}

struct SignalState {
  state: SignalPhase,
  pass_by_at: i64,
  is_approaching_station: bool,
}

pub fn SignalPlusSignal::event_signal_lookahead(
  self: &SignalPlusSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  train_distance: f64,
  check: SignalCheck,
  sc: &mut SimpleSimController,
  result: &mut SignalLookaheadResult
) {
  // show idle if train is farther than 1km, to avoid unnecessary processing
  if train_distance > 1000.0 {
    if let old_state &= ctx.db.view<SignalState>(signal) {
      sc.queue_erase(old_state);
    }
    return;
  }

  let state mut= SignalPhase::Idle;

  if check == SignalCheck::Stop {
    if train_distance <= 25.0 {
      result.max_speed = 10.0;
    } else if train_distance <= 100.0 {
      result.max_speed = 40.0;
    }
  }

  if check == SignalCheck::Pass {
    state = SignalPhase::Pass;
  }

  let is_approach_signal mut= false;
  if let run_dispatch &= motion.run_dispatch.get() {
    let run &= run_dispatch.run;
    if let line &= ctx.db.view(run.line_id) {
      if let current_stop &= run_dispatch.current_stop(line) {
        if let station &= ctx.db.view(current_stop.station_id) {
          if let sp_station &= ctx.db.view<SignalPlusStation>(station) {
            for approach_signal_id in sp_station.approach_signals.iter() {
              if (approach_signal_id.equals(signal.id)) {
                is_approach_signal = true;
                break;
              }
            }

            if is_approach_signal {
              state = SignalPhase::Caution;
            }
          }
        }
      }
    }
  }

  if check == SignalCheck::Stop {
    state = SignalPhase::Stop;
  }

  if let old_state &= ctx.db.view<SignalState>(signal) {
    sc.queue_erase(old_state);
  }

  let task = SignalState::new();
  task.state = state;
  task.is_approaching_station = is_approach_signal;
  sc.queue_attach(signal, task);
}

pub fn SignalPlusSignal::event_signal_pass_by(
  self: &SignalPlusSignal,
  ctx: &EventCtx,
  train: &Train,
  motion: &Motion,
  signal: &Signal,
  sc: &mut SimController
) {
  if let old_state &= ctx.db.view<SignalState>(signal) {
    let state = old_state.state;
    sc.queue_erase(old_state);
    let task = SignalState::new();
    if (state == SignalPhase::Stop || state == SignalPhase::Idle) {
      if (old_state.is_approaching_station) {
        task.state = SignalPhase::Caution;
      } else {
        task.state = SignalPhase::Pass;
      }
    }
    else {
      task.state = state;
    }
    task.pass_by_at = ctx.extrapolator.clock_us();
    sc.queue_attach(signal, task);
  }
}



pub fn SignalPlusSignal::event_signal_texture_state(
  self: &SignalPlusSignal,
  db: &DB,
  signal: &Signal,
  clock_us: i64,
  core_state: i64
): i64 {
  if let task &= db.view<SignalState>(signal) {
    if task.pass_by_at > 0 {
      if clock_us - task.pass_by_at >= 4000000 {
        return 2;
      }
    }

    if task.state == SignalPhase::Stop {
      log("stop", signal.id);
      let cycle = zmod(zdiv(clock_us, 500000), 2);  // Divide into 0.5s intervals
      if cycle == 0 {
        return 2;
      } else {
        return 0;
      }
    }

    if task.state == SignalPhase::Pass {
      log("pass", signal.id);
      return 1;
    }

    if task.state == SignalPhase::Caution {
      log("caution", signal.id);
      return 3;
    }

    if task.state == SignalPhase::Idle {
      log("idle", signal.id);
      return 2;
    }
  }
  
  for signal_id in self.signals_ahead.iter() {
    if let s &= db.view(signal_id) {
      if let ahead &= db.view<SignalState>(s) {
        if ahead.state == SignalPhase::Stop {
          return 3;
        }
      }
    }
  }

  return 2;
}
